package main

import (
	"fmt"
	"syscall"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

var (
	advapi32           = syscall.NewLazyDLL("advapi32.dll")
	regEnumValueW      = advapi32.NewProc("RegEnumValueW")
	regQueryInfoKeyW   = advapi32.NewProc("RegQueryInfoKeyW")
	regDeleteKeyW      = advapi32.NewProc("RegDeleteKeyW")
	regSetValueExW     = advapi32.NewProc("RegSetValueExW")
	regCreateKeyExW    = advapi32.NewProc("RegCreateKeyExW")
	
	shell32            = syscall.NewLazyDLL("shell32.dll")
	shellExecuteW      = shell32.NewProc("ShellExecuteW")
	
	kernel32           = syscall.NewLazyDLL("kernel32.dll")
	getModuleFileNameW = kernel32.NewProc("GetModuleFileNameW")
)

type RegValue struct {
	Name  string
	Type  uint32
	Data  string
}

type RegState struct {
	Subkeys map[string]bool
	Values  map[string]RegValue
}

func isAdmin() bool {
	var sid *windows.SID
	err := windows.AllocateAndInitializeSid(
		&windows.SECURITY_NT_AUTHORITY,
		2,
		windows.SECURITY_BUILTIN_DOMAIN_RID,
		windows.DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&sid,
	)
	if err != nil {
		return false
	}
	defer windows.FreeSid(sid)

	token := windows.GetCurrentProcessToken()
	member, err := token.IsMember(sid)
	if err != nil {
		return false
	}
	return member
}

func getExecutablePath() (string, error) {
	buf := make([]uint16, windows.MAX_PATH)
	ret, _, _ := getModuleFileNameW.Call(0, uintptr(unsafe.Pointer(&buf[0])), uintptr(len(buf)))
	if ret == 0 {
		return "", fmt.Errorf("failed to get executable path")
	}
	return syscall.UTF16ToString(buf), nil
}

func elevatePrivileges() error {
	exePath, err := getExecutablePath()
	if err != nil {
		return fmt.Errorf("failed to get executable path: %v", err)
	}

	verbPtr, _ := syscall.UTF16PtrFromString("runas")
	exePtr, _ := syscall.UTF16PtrFromString(exePath)
	cwdPtr, _ := syscall.UTF16PtrFromString("")

	ret, _, _ := shellExecuteW.Call(
		0,
		uintptr(unsafe.Pointer(verbPtr)),
		uintptr(unsafe.Pointer(exePtr)),
		0,
		uintptr(unsafe.Pointer(cwdPtr)),
		uintptr(1), // SW_NORMAL
	)

	if ret <= 32 {
		return fmt.Errorf("failed to elevate privileges, error code: %d", ret)
	}

	return nil
}

func canDeleteRegistryKey(keyPath string) bool {
	key, err := syscall.UTF16PtrFromString(keyPath)
	if err != nil {
		return false
	}

	var hKey windows.Handle
	err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, key, 0, windows.DELETE|windows.KEY_READ, &hKey)
	if err != nil {
		return false
	}
	windows.RegCloseKey(hKey)
	return true
}

func captureRegistryState(hKey windows.Handle, keyPath string) (*RegState, error) {
	state := &RegState{
		Subkeys: make(map[string]bool),
		Values:  make(map[string]RegValue),
	}

	err := captureKeyRecursive(hKey, "", state)
	if err != nil {
		return nil, err
	}

	return state, nil
}

func captureKeyRecursive(hKey windows.Handle, relativePath string, state *RegState) error {
	// Enumerate subkeys at this level
	var index uint32
	subkeyNames := []string{}
	for {
		nameBuf := make([]uint16, 256)
		nameLen := uint32(len(nameBuf))
		err := windows.RegEnumKeyEx(hKey, index, &nameBuf[0], &nameLen, nil, nil, nil, nil)
		if err == windows.ERROR_NO_MORE_ITEMS {
			break
		}
		if err != nil {
			return fmt.Errorf("error enumerating subkeys: %v", err)
		}
		subkeyName := syscall.UTF16ToString(nameBuf[:nameLen])
		
		fullPath := relativePath
		if fullPath != "" {
			fullPath += "\\"
		}
		fullPath += subkeyName
		
		state.Subkeys[fullPath] = true
		subkeyNames = append(subkeyNames, subkeyName)
		index++
	}

	// Enumerate values at this level
	index = 0
	for {
		nameBuf := make([]uint16, 16384)
		nameLen := uint32(len(nameBuf))
		var valueType uint32
		dataBuf := make([]byte, 16384)
		dataLen := uint32(len(dataBuf))

		ret, _, _ := regEnumValueW.Call(
			uintptr(hKey),
			uintptr(index),
			uintptr(unsafe.Pointer(&nameBuf[0])),
			uintptr(unsafe.Pointer(&nameLen)),
			0,
			uintptr(unsafe.Pointer(&valueType)),
			uintptr(unsafe.Pointer(&dataBuf[0])),
			uintptr(unsafe.Pointer(&dataLen)),
		)

		if ret == uintptr(windows.ERROR_NO_MORE_ITEMS) {
			break
		}
		if ret != 0 {
			return fmt.Errorf("error enumerating values: error code %d", ret)
		}

		valueName := syscall.UTF16ToString(nameBuf[:nameLen])
		valueData := formatRegValue(valueType, dataBuf[:dataLen])
		
		fullPath := relativePath
		if fullPath != "" {
			fullPath += "\\"
		}
		fullPath += valueName
		
		state.Values[fullPath] = RegValue{
			Name: fullPath,
			Type: valueType,
			Data: valueData,
		}
		index++
	}

	// Recursively process each subkey
	for _, subkeyName := range subkeyNames {
		subkeyPtr, err := syscall.UTF16PtrFromString(subkeyName)
		if err != nil {
			continue
		}

		var hSubKey windows.Handle
		err = windows.RegOpenKeyEx(hKey, subkeyPtr, 0, windows.KEY_READ, &hSubKey)
		if err != nil {
			// Skip keys we can't open (permission issues, etc.)
			continue
		}

		fullPath := relativePath
		if fullPath != "" {
			fullPath += "\\"
		}
		fullPath += subkeyName

		captureKeyRecursive(hSubKey, fullPath, state)
		windows.RegCloseKey(hSubKey)
	}

	return nil
}

func formatRegValue(valueType uint32, data []byte) string {
	switch valueType {
	case windows.REG_SZ, windows.REG_EXPAND_SZ:
		if len(data) < 2 {
			return ""
		}
		u16 := make([]uint16, len(data)/2)
		for i := 0; i < len(u16); i++ {
			u16[i] = uint16(data[i*2]) | uint16(data[i*2+1])<<8
		}
		return syscall.UTF16ToString(u16)
	case windows.REG_DWORD:
		if len(data) >= 4 {
			return fmt.Sprintf("0x%08x", uint32(data[0])|uint32(data[1])<<8|uint32(data[2])<<16|uint32(data[3])<<24)
		}
	case windows.REG_QWORD:
		if len(data) >= 8 {
			return fmt.Sprintf("0x%016x", uint64(data[0])|uint64(data[1])<<8|uint64(data[2])<<16|uint64(data[3])<<24|
				uint64(data[4])<<32|uint64(data[5])<<40|uint64(data[6])<<48|uint64(data[7])<<56)
		}
	case windows.REG_BINARY, windows.REG_MULTI_SZ:
		return fmt.Sprintf("%d bytes", len(data))
	}
	return fmt.Sprintf("Unknown type %d", valueType)
}

func deleteRegistryKey(baseKeyPath, relativePath string) error {
	// Open the parent key
	fullPath := baseKeyPath
	if relativePath != "" {
		fullPath = baseKeyPath + "\\" + relativePath
	}

	keyPtr, err := syscall.UTF16PtrFromString(fullPath)
	if err != nil {
		return fmt.Errorf("error converting key path: %v", err)
	}

	var hKey windows.Handle
	err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, keyPtr, 0, windows.DELETE, &hKey)
	if err != nil {
		return fmt.Errorf("error opening key for deletion: %v", err)
	}
	defer windows.RegCloseKey(hKey)

	// Delete the key
	ret, _, _ := regDeleteKeyW.Call(uintptr(hKey), uintptr(0))
	if ret != 0 {
		return fmt.Errorf("error deleting key: error code %d", ret)
	}

	return nil
}

func deleteRegistryKeyRecursive(baseKeyPath, relativePath string) error {
	fullPath := baseKeyPath
	if relativePath != "" {
		fullPath = baseKeyPath + "\\" + relativePath
	}

	keyPtr, err := syscall.UTF16PtrFromString(fullPath)
	if err != nil {
		return fmt.Errorf("error converting key path: %v", err)
	}

	var hKey windows.Handle
	err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, keyPtr, 0, windows.KEY_READ|windows.DELETE, &hKey)
	if err != nil {
		return fmt.Errorf("error opening key: %v", err)
	}
	defer windows.RegCloseKey(hKey)

	// Enumerate and delete all subkeys first
	for {
		nameBuf := make([]uint16, 256)
		nameLen := uint32(len(nameBuf))
		err := windows.RegEnumKeyEx(hKey, 0, &nameBuf[0], &nameLen, nil, nil, nil, nil)
		if err == windows.ERROR_NO_MORE_ITEMS {
			break
		}
		if err != nil {
			return fmt.Errorf("error enumerating subkeys: %v", err)
		}
		subkeyName := syscall.UTF16ToString(nameBuf[:nameLen])
		
		// Recursively delete subkey
		subkeyPath := relativePath
		if subkeyPath != "" {
			subkeyPath += "\\"
		}
		subkeyPath += subkeyName
		
		err = deleteRegistryKeyRecursive(baseKeyPath, subkeyPath)
		if err != nil {
			fmt.Printf("Warning: failed to delete subkey %s: %v\n", subkeyPath, err)
		}
	}

	// Now delete this key
	windows.RegCloseKey(hKey)
	
	keyPtr, _ = syscall.UTF16PtrFromString(relativePath)
	parentPath := baseKeyPath
	if relativePath != "" {
		// Open parent and delete this key
		lastSlash := -1
		for i := len(relativePath) - 1; i >= 0; i-- {
			if relativePath[i] == '\\' {
				lastSlash = i
				break
			}
		}
		
		if lastSlash >= 0 {
			parentPath = baseKeyPath + "\\" + relativePath[:lastSlash]
			keyName := relativePath[lastSlash+1:]
			keyPtr, _ = syscall.UTF16PtrFromString(keyName)
		} else {
			keyPtr, _ = syscall.UTF16PtrFromString(relativePath)
		}
		
		parentKeyPtr, _ := syscall.UTF16PtrFromString(parentPath)
		var hParentKey windows.Handle
		err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, parentKeyPtr, 0, windows.DELETE, &hParentKey)
		if err != nil {
			return fmt.Errorf("error opening parent key: %v", err)
		}
		defer windows.RegCloseKey(hParentKey)
		
		ret, _, _ := regDeleteKeyW.Call(uintptr(hParentKey), uintptr(unsafe.Pointer(keyPtr)))
		if ret != 0 {
			return fmt.Errorf("error deleting key: error code %d", ret)
		}
	}

	return nil
}

func printDiff(oldState, newState *RegState, keyPath string) {
	fmt.Println("\n========== CHANGES DETECTED ==========")
	fmt.Println("Time:", time.Now().Format(time.RFC3339))
	fmt.Println("Key:", keyPath)
	fmt.Println("======================================")

	hasChanges := false

	// Check for added/removed subkeys
	for name := range newState.Subkeys {
		if !oldState.Subkeys[name] {
			fmt.Printf("[SUBKEY ADDED] %s\n", name)
			hasChanges = true
			
			// Check if the key name contains "ExtensionInstallForcelist"
			if contains(name, "ExtensionInstallForcelist") {
				fmt.Printf("  âš ï¸  DETECTED ExtensionInstallForcelist - PROCESSING...\n")
				
				// Verify we have permissions before attempting
				if !isAdmin() {
					fmt.Printf("  âŒ Insufficient privileges to delete. Run as Administrator.\n")
				} else {
					// Read all values from the forcelist key
					fullKeyPath := keyPath + "\\" + name
					values, err := readKeyValues("", fullKeyPath)
					if err != nil {
						fmt.Printf("  âš ï¸  Could not read key values: %v\n", err)
					} else {
						// Process each value to extract extension IDs
						extensionIDs := []string{}
						for valueName, valueData := range values {
							fmt.Printf("  ðŸ“‹ Found value %s = %s\n", valueName, valueData)
							extensionID := extractExtensionIDFromValue(valueData)
							if extensionID != "" && extensionID != valueData {
								fmt.Printf("  ðŸ” Extracted extension ID: %s\n", extensionID)
								extensionIDs = append(extensionIDs, extensionID)
							} else if extensionID != "" {
								extensionIDs = append(extensionIDs, extensionID)
							}
						}
						
						// Add each extension ID to the blocklist
						if len(extensionIDs) > 0 {
							blocklistPath := getBlocklistKeyPath(name)
							fmt.Printf("  ðŸ“ Adding to blocklist: %s\n", blocklistPath)
							
							for _, extID := range extensionIDs {
								err := addToBlocklist(keyPath, blocklistPath, extID)
								if err != nil {
									fmt.Printf("  âš ï¸  Failed to add %s to blocklist: %v\n", extID, err)
								}
							}
						}
					}
					
					// Now delete the forcelist key
					fmt.Printf("  ðŸ—‘ï¸  Deleting forcelist key...\n")
					err = deleteRegistryKeyRecursive(keyPath, name)
					if err != nil {
						fmt.Printf("  âŒ Failed to delete key: %v\n", err)
					} else {
						fmt.Printf("  âœ“ Successfully deleted key: %s\n", name)
						// Remove from newState since we deleted it
						delete(newState.Subkeys, name)
					}
				}
			}
		}
	}
	for name := range oldState.Subkeys {
		if !newState.Subkeys[name] {
			fmt.Printf("[SUBKEY REMOVED] %s\n", name)
			hasChanges = true
		}
	}

	// Check for added/modified/removed values
	for name, newVal := range newState.Values {
		oldVal, exists := oldState.Values[name]
		if !exists {
			fmt.Printf("[VALUE ADDED] %s = %s (type: %d)\n", name, newVal.Data, newVal.Type)
			hasChanges = true
		} else if oldVal.Data != newVal.Data || oldVal.Type != newVal.Type {
			fmt.Printf("[VALUE MODIFIED] %s\n", name)
			fmt.Printf("  Old: %s (type: %d)\n", oldVal.Data, oldVal.Type)
			fmt.Printf("  New: %s (type: %d)\n", newVal.Data, newVal.Type)
			hasChanges = true
		}
	}
	for name, oldVal := range oldState.Values {
		if _, exists := newState.Values[name]; !exists {
			fmt.Printf("[VALUE REMOVED] %s = %s\n", name, oldVal.Data)
			hasChanges = true
		}
	}

	if !hasChanges {
		fmt.Println("(No specific changes detected)")
	}
	fmt.Println("======================================\n")
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || 
		(len(s) > len(substr) && 
		 indexOf(s, substr) >= 0))
}

func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		match := true
		for j := 0; j < len(substr); j++ {
			if s[i+j] != substr[j] && s[i+j] != substr[j]+32 && s[i+j]+32 != substr[j] {
				match = false
				break
			}
		}
		if match {
			return i
		}
	}
	return -1
}

func extractExtensionIDFromValue(value string) string {
	// Extension ID is the string before the first ';'
	for i := 0; i < len(value); i++ {
		if value[i] == ';' {
			return value[:i]
		}
	}
	return value
}

func readKeyValues(baseKeyPath, relativePath string) (map[string]string, error) {
	fullPath := baseKeyPath
	if relativePath != "" {
		fullPath = baseKeyPath + "\\" + relativePath
	}

	keyPtr, err := syscall.UTF16PtrFromString(fullPath)
	if err != nil {
		return nil, fmt.Errorf("error converting key path: %v", err)
	}

	var hKey windows.Handle
	err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, keyPtr, 0, windows.KEY_READ, &hKey)
	if err != nil {
		return nil, fmt.Errorf("error opening key: %v", err)
	}
	defer windows.RegCloseKey(hKey)

	values := make(map[string]string)
	var index uint32
	for {
		nameBuf := make([]uint16, 16384)
		nameLen := uint32(len(nameBuf))
		var valueType uint32
		dataBuf := make([]byte, 16384)
		dataLen := uint32(len(dataBuf))

		ret, _, _ := regEnumValueW.Call(
			uintptr(hKey),
			uintptr(index),
			uintptr(unsafe.Pointer(&nameBuf[0])),
			uintptr(unsafe.Pointer(&nameLen)),
			0,
			uintptr(unsafe.Pointer(&valueType)),
			uintptr(unsafe.Pointer(&dataBuf[0])),
			uintptr(unsafe.Pointer(&dataLen)),
		)

		if ret == uintptr(windows.ERROR_NO_MORE_ITEMS) {
			break
		}
		if ret != 0 {
			return nil, fmt.Errorf("error enumerating values: error code %d", ret)
		}

		valueName := syscall.UTF16ToString(nameBuf[:nameLen])
		valueData := formatRegValue(valueType, dataBuf[:dataLen])
		values[valueName] = valueData
		index++
	}

	return values, nil
}

func getBlocklistKeyPath(forcelistPath string) string {
	// Replace "ExtensionInstallForcelist" with "ExtensionInstallBlocklist"
	result := ""
	for i := 0; i < len(forcelistPath); i++ {
		if i+len("ExtensionInstallForcelist") <= len(forcelistPath) {
			match := true
			for j := 0; j < len("ExtensionInstallForcelist"); j++ {
				c1 := forcelistPath[i+j]
				c2 := "ExtensionInstallForcelist"[j]
				if c1 != c2 && c1 != c2+32 && c1+32 != c2 {
					match = false
					break
				}
			}
			if match {
				result += "ExtensionInstallBlocklist"
				i += len("ExtensionInstallForcelist") - 1
				continue
			}
		}
		result += string(forcelistPath[i])
	}
	return result
}

func addToBlocklist(baseKeyPath, blocklistPath, extensionID string) error {
	fullPath := baseKeyPath
	if blocklistPath != "" {
		fullPath = baseKeyPath + "\\" + blocklistPath
	}

	keyPtr, err := syscall.UTF16PtrFromString(fullPath)
	if err != nil {
		return fmt.Errorf("error converting key path: %v", err)
	}

	var hKey windows.Handle
	var disposition uint32
	
	// Try to open or create the key
	ret, _, _ := regCreateKeyExW.Call(
		uintptr(windows.HKEY_LOCAL_MACHINE),
		uintptr(unsafe.Pointer(keyPtr)),
		0,
		0,
		0,
		uintptr(windows.KEY_READ|windows.KEY_WRITE),
		0,
		uintptr(unsafe.Pointer(&hKey)),
		uintptr(unsafe.Pointer(&disposition)),
	)
	
	if ret != 0 {
		return fmt.Errorf("error creating/opening blocklist key: error code %d", ret)
	}
	defer windows.RegCloseKey(hKey)

	// Read existing values to find the next available index
	existingValues, _ := readKeyValues(baseKeyPath, blocklistPath)
	
	// Check if extension ID already exists
	for _, value := range existingValues {
		if value == extensionID {
			fmt.Printf("  â„¹ï¸  Extension ID %s already in blocklist\n", extensionID)
			return nil
		}
	}

	// Find the next available numeric index
	nextIndex := 1
	for {
		indexStr := fmt.Sprintf("%d", nextIndex)
		if _, exists := existingValues[indexStr]; !exists {
			break
		}
		nextIndex++
	}

	// Add the extension ID to the blocklist
	indexName := fmt.Sprintf("%d", nextIndex)
	indexNamePtr, _ := syscall.UTF16PtrFromString(indexName)
	
	// Convert extension ID to UTF-16
	extensionIDUTF16, _ := syscall.UTF16FromString(extensionID)
	dataSize := uint32(len(extensionIDUTF16) * 2)

	ret, _, _ = regSetValueExW.Call(
		uintptr(hKey),
		uintptr(unsafe.Pointer(indexNamePtr)),
		0,
		uintptr(windows.REG_SZ),
		uintptr(unsafe.Pointer(&extensionIDUTF16[0])),
		uintptr(dataSize),
	)

	if ret != 0 {
		return fmt.Errorf("error setting blocklist value: error code %d", ret)
	}

	fmt.Printf("  âœ“ Added extension ID %s to blocklist at index %s\n", extensionID, indexName)
	return nil
}

func main() {
	// Check if running as administrator
	if !isAdmin() {
		fmt.Println("âš ï¸  WARNING: Not running as Administrator")
		fmt.Println("Registry deletion requires elevated privileges.")
		fmt.Print("Attempting to elevate permissions... ")
		
		err := elevatePrivileges()
		if err != nil {
			fmt.Printf("âŒ Failed: %v\n", err)
			fmt.Println("\nPlease run this program as Administrator to enable key deletion.")
			fmt.Println("Press Enter to continue in read-only mode...")
			fmt.Scanln()
		} else {
			fmt.Println("âœ“ Relaunching with elevated privileges...")
			// Exit this instance as the elevated one is starting
			return
		}
	} else {
		fmt.Println("âœ“ Running with Administrator privileges")
	}

	// Open the registry key to monitor
	keyPath := `SOFTWARE\Policies`
	
	// Test if we can actually delete keys
	canDelete := canDeleteRegistryKey(keyPath)
	if !canDelete {
		fmt.Println("âš ï¸  WARNING: Insufficient permissions to delete registry keys")
		fmt.Println("Key deletion features will be disabled.")
	} else {
		fmt.Println("âœ“ Registry deletion permissions verified")
	}
	
	key, err := syscall.UTF16PtrFromString(keyPath)
	if err != nil {
		fmt.Println("Error converting key path:", err)
		return
	}

	var hKey windows.Handle
	err = windows.RegOpenKeyEx(windows.HKEY_LOCAL_MACHINE, key, 0, windows.KEY_NOTIFY|windows.KEY_READ|windows.DELETE, &hKey)
	if err != nil {
		fmt.Println("Error opening registry key:", err)
		return
	}
	defer windows.RegCloseKey(hKey)

	// Capture initial state
	fmt.Println("Capturing initial registry state...")
	previousState, err := captureRegistryState(hKey, keyPath)
	if err != nil {
		fmt.Println("Error capturing initial state:", err)
		return
	}
	fmt.Printf("Initial state: %d subkeys, %d values\n", len(previousState.Subkeys), len(previousState.Values))

	// Create an event for notifications
	event, err := windows.CreateEvent(nil, 0, 0, nil)
	if err != nil {
		fmt.Println("Error creating event:", err)
		return
	}
	defer windows.CloseHandle(event)

	// Start monitoring the registry key
	err = windows.RegNotifyChangeKeyValue(hKey, true, windows.REG_NOTIFY_CHANGE_NAME|windows.REG_NOTIFY_CHANGE_LAST_SET, event, true)
	if err != nil {
		fmt.Println("Error setting up registry notification:", err)
		return
	}

	fmt.Println("Monitoring registry changes...")

	for {
		// Wait for a change notification
		status, err := windows.WaitForSingleObject(event, windows.INFINITE)
		if err != nil {
			fmt.Println("Error waiting for event:", err)
			return
		}

		if status == windows.WAIT_OBJECT_0 {
			// Capture new state
			newState, err := captureRegistryState(hKey, keyPath)
			if err != nil {
				fmt.Println("Error capturing new state:", err)
			} else {
				// Print the differences
				printDiff(previousState, newState, keyPath)
				// Update previous state
				previousState = newState
			}

			// Re-arm the notification
			err = windows.RegNotifyChangeKeyValue(hKey, true, windows.REG_NOTIFY_CHANGE_NAME|windows.REG_NOTIFY_CHANGE_LAST_SET, event, true)
			if err != nil {
				fmt.Println("Error re-arming registry notification:", err)
				return
			}
		}
	}
}
